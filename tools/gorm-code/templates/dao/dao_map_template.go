package dao_template

var daoMapTemplateStr = `// Code generated by TX.
// Template: Map Dao

package {{.DaoPackage}}
{{ if .DaoImports }}
import (
{{- range .DaoImports}}
    {{.}}
{{- end}}
){{end}}

var (
	def{{.TableName}} = &db_types.{{.TableName}}{}
)
{{$structName := CamelizeStr .TableName .SystemName}}{{$hasField := .HasFields}}
func Query{{.TableName}}All(dbId int{{- if $hasField }}, {{.GormFieldsInputs}}{{end}}) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryListString({{.GormFieldsValue}})).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
    
    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            return list, err
        }
        list = append(list, info)
    }
    return list, err
}

{{- range .QueryFields}}

func Query{{.TableName}}By{{.QueryKey}}(dbId int, {{.QueryInput}}) (info *{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.Query{{.QueryKey}}String({{.QueryValue}})).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
        
    if rows.Next() {
        info = {{.PoolPackage}}.Get{{$structName}}()
        err = database.ScanRows(rows, info.Get{{.TableName}}())
    }
    return info, err
}

func Query{{.TableName}}By{{.QueryKey}}List(dbId int, {{.QueryInput}}) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.Query{{.QueryKey}}String({{.QueryValue}})).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
    
    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            return list, err
        }
        list = append(list, info)
    }
    return list, err
}

{{- end}}

func Create{{.TableName}}(dbId int, info *{{.TypePackage}}.{{$structName}}) (*{{.TypePackage}}.{{$structName}}, error) {
	if tx := {{.MySqlClient}}.Omit(def{{.TableName}}.CreateOmits()...).Create(info.Get{{.TableName}}()); tx.Error != nil {
		return info, tx.Error
	} else if tx.RowsAffected != 1 {
		return info, errors.New("Create{{.TableName}} RowsAffected is Zero")
	}
	return info, nil
}

func Create{{.TableName}}List(dbId int, list []*{{.TypePackage}}.{{$structName}}) error {
	if len(list) <= 0 {
		return nil
	}
    var _list []*db_types.{{.TableName}}
    for _, info := range list {
        _list = append(_list, info.Get{{.TableName}}())
    }
	if tx := {{.MySqlClient}}.Omit(def{{.TableName}}.CreateOmits()...).CreateInBatches(_list, len(_list)); tx.Error != nil {
		return tx.Error
	} else if tx.RowsAffected < int64(len(list)) {
		return errors.New("Create{{.TableName}}List RowsAffected is error" + xutil.NumToString(tx.RowsAffected))
	}
	return nil
}

func Update{{.TableName}}(dbId int, info *{{.TypePackage}}.{{$structName}}) error {
    return {{.MySqlClient}}.Select(info.GetDirtyFlags()){{- if not .OnlyPrimaryKey}}.Where(info.Get{{.TableName}}().WhereString()){{- end}}.UpdateColumns(info.Get{{.TableName}}()).Error
}

func Save{{.TableName}}(dbId int, info *{{.TypePackage}}.{{$structName}}) (*{{.TypePackage}}.{{$structName}}, error) {
    return info, {{.MySqlClient}}.Model(info.Get{{.TableName}}()).Where(info.Get{{.TableName}}().WhereString()).Save(info.Get{{.TableName}}()).Error
}

func Delete{{.TableName}}(dbId int, info *{{.TypePackage}}.{{$structName}}) error {
	if tx := {{.MySqlClient}}{{- if not .OnlyPrimaryKey}}.Where(info.Get{{.TableName}}().WhereString()){{- end}}.Delete(info.Get{{.TableName}}()); tx.Error != nil {
		return tx.Error
	} else if tx.RowsAffected != 1 {
		return errors.New("Delete{{.TableName}} RowsAffected is Error" + xutil.NumToString(tx.RowsAffected))
	}
	return nil
}

func Delete{{.TableName}}List({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}dbId int, list []{{.PrimaryKey.GoType}}) error {
    if tx := {{.MySqlClient}}.Where(def{{.TableName}}.WhereList({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}}, {{end}}{{end}}list)).Delete(def{{.TableName}}); tx.Error != nil {
		return tx.Error
	} else if tx.RowsAffected != int64(len(list)) {
		return errors.New("Delete{{.TableName}}List RowsAffected is Error" + xutil.NumToString(tx.RowsAffected))
	}
	return nil
}

func Query{{.TableName}}List({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}dbId int, ids []{{.PrimaryKey.GoType}}) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.WhereList({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}}, {{end}}{{end}}ids)).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)

    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
    }
    return list, err
}

{{- range .NextFields}}

func Query{{.TableName}}NextList({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}dbId int, {{.Name}} {{.GoType}}) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryNextString({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}}, {{end}}{{- end}}{{.Name}})).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
        
    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
    }
    return list, err
}

func Query{{.TableName}}NextLimitList({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}dbId int, {{.Name}} {{.GoType}}, limit int) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryNextString({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}}, {{end}}{{end}}{{.Name}})).Limit(limit).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
    
    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
   }
    return list, err
}
{{- end}}

{{- range .LikeFields}}

func Query{{.TableName}}LikeList(dbId int, {{.Name}} {{.GoType}}, limit int) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryLikeString({{.Name}})).Limit(limit).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)

    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
    }
    return list, err
}

func Query{{.TableName}}LikeListFromId(dbId int, {{.Name}} {{.GoType}}, fromId int64, limit int) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryLikeFromId({{.Name}}, fromId)).Limit(limit).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)
        
    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
    }
    return list, err
}
{{- end}}

{{- range .GroupFields}}

func Query{{.TableName}}GroupList({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}dbId int, {{.Name}} {{.GoType}}) (list []*{{.TypePackage}}.{{$structName}}, err error) {
    database := {{.MySqlClient}}
    rows, err := database.Model(def{{.TableName}}).Where(def{{.TableName}}.QueryGroupString({{- if $hasField }}{{- range .GormFields}}{{.FieldValue}} {{.FieldType}}, {{end}}{{end}}{{.Name}})).Rows()
    if err != nil {
        return nil, err
    }
    defer xutil.RowsClose(rows)

    for rows.Next() {
        info := {{.PoolPackage}}.Get{{$structName}}()
        if err = database.ScanRows(rows, info.Get{{.TableName}}()); err != nil {
            {{.PoolPackage}}.Put{{$structName}}(info)
        } else {
            list = append(list, info)
        }
    }
    return list, err
}
{{- end}}
`
